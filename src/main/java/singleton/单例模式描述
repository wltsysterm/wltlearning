3.单例模式的克隆
上面分析了单例模式的线程安全问题，还有个问题就是需要考虑单例模式中对象的复制问题。在java中，对象默认是不可以被复制的，但是若实现了Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象复制不是调用类的构造方法，所以即使是私有的构造方法，对象仍然是可以被复制的。但是在一般情况下，单例类很少会主动要求被复制的，所以解决该问题最好的方法就是单例类不要实现Cloneable接口即可。
5. 单例模式的优缺点
      优点：
        1.在内存中只存在一个实例，所有减小诶村的开支，特别是一个对象需要频繁的创建和销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显；
        2.减小了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留在内存中。
        3.可以避免对资源的多重占用，如写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。
        4.单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。
      缺点：
        1.单例模式没有接口，扩展很难，若要扩展，除了修改代码基本上没有第二种途径可以实现
        2.单例模式对测试是不利的，在并行开发环境中，如果单例模式没有完成，是不能进行测试的。
6. 单例模式的应用场景
      在一个系统中，要求一个类仅有一个对象时，可以采用单例模式：
        1. 要求生成唯一序列号的环境。
        2. 在整个项目中需要一个共享访问点或共享数据，例如一个web页面上的访问量，可以不用每次刷新都把记录存到数据库，但是要确保单例线程安全。
        3. 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源。
        4. 需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式，当然也可以直接声明为static方式。
        Spring中也用到了单例模式，每个Bean默认就是单例的，这样做的有点事Spring容器可以管理这些Bean的生命期，决定什么时候创建出来，什么时候销毁，销毁的时候要如何处理等等。如果采用非单例模式（Prototype类型），则Bean初始化后的管理交给J2EE容器了，Spring容器就不在跟踪管理Bean的生命周期了。